# include "specs.h"

/************************************************************/

int process_almt (Options *options, Alignment *alignment) {
    
    int retval;
    int count_gaps (Alignment * alignment);
    int seq_pw_dist(Alignment * alignment);
    /* gaps */
    count_gaps (alignment);

    alignment->seq_dist = NULL;

    /*allocate space for various indicators of sequence similarity*/
    alignment->seq_dist =
	dmatrix ( alignment->number_of_seqs, alignment->number_of_seqs);
    
    alignment->aligned_sites =
	intmatrix ( alignment->number_of_seqs, alignment->number_of_seqs);
    if ( ! alignment->aligned_sites ) return 1;
    
    alignment->identical_sites =
	intmatrix ( alignment->number_of_seqs, alignment->number_of_seqs);
    if ( ! alignment->identical_sites ) return 1;
    
    alignment->similar_sites =
	intmatrix ( alignment->number_of_seqs, alignment->number_of_seqs);
    if ( ! alignment->similar_sites ) return 1;
    
 



    
    retval   = seq_pw_dist (alignment);
    if ( retval) return retval;
    
    return 0;
}

/*****************************************************************/
int count_gaps (Alignment * alignment) {

    int s, c;
    alignment->seq_gaps    = (int *) emalloc (alignment->number_of_seqs*sizeof(int));
    if (!alignment->seq_gaps) return 1;
    alignment->column_gaps = (int *) emalloc (alignment->length*sizeof(int));
    if (!alignment->column_gaps) return 1;
    for ( s=0; s<alignment->number_of_seqs; s++ ) {
	for ( c=0; c<alignment->length; c++) {
	    if ( alignment->sequence[s][c] == '.' ) {
		alignment->column_gaps[c] ++;
		alignment->seq_gaps[s] ++;
	    }
	}
    }
    alignment->query_gaps = 0;
    int pos = 0;
    for ( c=0; c<alignment->length; c++) {
	if ( alignment->query_seq[c] == '.' ) {
	    alignment->query_gaps ++;
	} else {
	    pos ++;
	    
	}
    }
    
    return 0;
}
